#!/bin/bash

# It is appealing to use an interactive shell to run this script so that the
# users bashrc can choose a different INPUTRC.  We suggest the user changing
# their .inputrc config file to have a condition for `TERM=dumb` in it and
# choosing `set editing-mode emacs` under that clause.  However we also want to
# support users changing the INPUTRC environment variable in their bashrc (on
# the principle that most people are more comfortable changing settings in
# bashrc than anywhere else).
#
# However, on experiment it seems like that comes with downsides in error cases
# which we do not think are worth the trade-off.
# See github issue #32.

# TODO Have to play around with these settings to find the most useful for vsh.
# stty -echonl -icanon -iexten isig onocr
stty tabs -onlcr icanon -echo -onlcr iexten isig -echonl -crterase

export PAGER=
export MANPAGER="$1/vsh_man_pager"
export GIT_PAGER='col -b'

# N.b. These variables are in the `vim` environment, but not the `nvim`
# environment.  With these set some commands change their output to fit the
# size of the terminal that is reported, I don't think it's a good idea to take
# this info since the vsh file will naturally have different column widths.
unset COLUMNS
unset LINES


if [[ -n "$VSH_EMACS_BUFFER" ]]; then
    export EDITOR="emacsclient"
    vsh_buffer="$VSH_EMACS_BUFFER"
else
    export EDITOR="$1/vsh_editor_prog"
    vsh_buffer="$VSH_VIM_BUFFER"
fi

# It's really awkward to find out what the bindings are programmatically
# (or at least I don't know of a nice way to query the readline library).
completions_binding="$(bind -q possible-completions 2>/dev/null)"
glob_binding="$(bind -q glob-list-expansions 2>/dev/null)"
discard_line="$(bind -q unix-line-discard 2>/dev/null)"

# Set INPUTRC environment variable to a special temporary one.
# Then we can add special configuration according to what is best for this
# plugin.
# Caveats:
# - Does not cross `su` boundaries, nor does it work on the remote
#   machine.  Hence still want to parse completion commands from the
#   environment (on the assumption that those would be whatever the user is
#   planning on using and possibly has set up elsewhere).  Hence would very
#   much like to only *adjust* INPUTRC rather than override it.
#   Do this by using `$import` and the original INPUTRC.
# - Caveat of above logic is that it's reasonably likely that the user would
#   simply "deal with" whatever the other shell uses outside of `vsh`.  So
#   things could easily still be completely different.
# - Another problem is that user may have set bindings in `bash` rather than
#   readline.
#   Assume that if this is the case we've picked it up with `bind -q` above,
#   and hence avoid overriding things with our special INPUTRC.
#   N.b. Probably best to parse the keys user has set up in their environment,
#   then put them into the generated INPUTRC.  That way can ensure things like
#   GDB have the same commands.
setup-inputrc () {
  temp_file="$(mktemp)"
  if [[ -n "$INPUTRC" ]]; then
    echo "\$include $INPUTRC" > $temp_file
  elif [[ -f "$HOME/.inputrc" ]]; then
    echo "\$include $HOME/.inputrc" > $temp_file
  else
    echo "\$include /etc/inputrc" > $temp_file
  fi
  if [[ -n "$2" ]]; then
    echo 'Meta-=: possible-completions' >> $temp_file
    echo 'Control-x g: glob-list-expansions' >> $temp_file
    echo 'Control-u: unix-line-discard' >> $temp_file
  fi
  cat "$1/vsh_inputrc_snippet" >> $temp_file
  echo "$temp_file"
}

if [[ "$completions_binding" == *'not bound to any keys'* ]] || \
  [[ "$glob_binding" == *'not bound to any keys'* ]] || \
  [[ "$discard_line" == *'not bound to any keys'* ]]; then
  # Just let any errors raise -- we'll see their stack in the buffer.
  # Use defaults that should work when there was no existing binding.
  export INPUTRC="$(setup-inputrc $1 include-bindings)"
  "$1/vsh_tell_editor_bindings.py" \
        'possible-completions can be invoked via "\e=".' \
        'glob-list-expansions can be invoked via "\C-xg".' \
        'unix-line-discard can be invoked via "\C-u".' \
        "$vsh_buffer" \
        "$INPUTRC"

else
  # Just let any errors raise -- we'll see their stack in the buffer.
  export INPUTRC="$(setup-inputrc $1)"
  "$1/vsh_tell_editor_bindings.py" \
        "$completions_binding" \
        "$glob_binding" \
        "$discard_line" \
        "$vsh_buffer" \
        "$INPUTRC"
fi
exec "$2"
