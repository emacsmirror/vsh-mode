# TODO
#   Find what command line arguments need to be given to a vim instance in
#   order to just run these tests.


#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#
#                                   Motion                                    #
#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#
Given vsh (vsh buffer):
  vshcmd: >
  vshcmd: >    #echo Hello there
  vshcmd: >    echo Hello there

Do (Motion down skips comments and empty lines):
  \<C-n>ix

Expect:
  vshcmd: >
  vshcmd: >    #echo Hello there
  vshcmd: >    xecho Hello there

Do (Motion down with no extra prompts stays at end):
  \<C-n>\<C-n>ix

Expect:
  vshcmd: >
  vshcmd: >    #echo Hello there
  vshcmd: >    xecho Hello there

Do (Down motion with count also stops):
  2\<C-n>ix

Expect:
  vshcmd: >
  vshcmd: >    #echo Hello there
  vshcmd: >    xecho Hello there


Do (Moving up at start of file does nothing):
  \<C-p>ix

Expect:
  xvshcmd: >
  vshcmd: >    #echo Hello there
  vshcmd: >    echo Hello there


Do (Moving up with no previous prompt goes to top):
  \<C-n>\<C-p>ix

Expect:
  xvshcmd: >
  vshcmd: >    #echo Hello there
  vshcmd: >    echo Hello there


Given vsh (vsh buffer):
  vshcmd: > echo Hello there
  Hello there, this is output

Do (Moving down at last prompt moves to end of output):
  \<C-n>\<C-n>ix

Expect:
  vshcmd: > echo Hello there
  xHello there, this is output

Do (Down motion with count does same):
  2\<C-n>ix

Expect:
  vshcmd: > echo Hello there
  xHello there, this is output

Do (Moving up on top prompt doesn't move cursor):
  \<C-n>\<C-p>ix

Expect:
  vshcmd: > xecho Hello there
  Hello there, this is output

Given vsh (vsh buffer):
  vshcmd: > # vshcmd: > ls
  vshcmd: > ls

Do (Down motion includes saved output):
  \<C-n>ix

Expect:
  vshcmd: > # vshcmd: > xls
  vshcmd: > ls

Do (Up motion includes saved output):
  \<C-n>\<C-n>\<C-p>ix

Expect:
  vshcmd: > # vshcmd: > xls
  vshcmd: > ls


Given vsh (vsh buffer):
  vshcmd: > 
  vshcmd: > ls

Do (Down motion includes complete prompts without commands):
  \<C-n>ix

Expect:
  vshcmd: >x 
  vshcmd: > ls

Do (Up motion includes complete prompts without commands):
  \<C-n>\<C-n>\<C-p>ix

Expect:
  vshcmd: >x 
  vshcmd: > ls


# In Operator Pending mode we select *up to* the previous prompt
Given vsh (vsh buffer):
  vshcmd: > ls
  many
  many
  files
  vshcmd: > ls 2

Do (omode up motion does not select command above):
  jjd\<C-p>

Expect:
  vshcmd: > ls
  files
  vshcmd: > ls 2

Do (omode down motion does not select command below):
  jj$d\<C-n>

Expect:
  vshcmd: > ls
  many
  vshcmd: > ls 2

Do (omode down motion from inside a prompt removes that prompt only):
  d\<C-n>

Expect:
  many
  many
  files
  vshcmd: > ls 2

Do (omode down motion from inside a command at the top of the file removes the current prompt only):
  $d\<C-n>

Expect:
  vshcmd: > ls 2

Do (omode up motion from inside a command removes the current prompt and output):
  2\<C-n>$d\<C-p>

Expect:
  vshcmd: > ls

Do (omode up motion from inside a prompt removes the current prompt and output):
  2\<C-n>0d\<C-p>

Expect:
  vshcmd: > ls

Given vsh (vsh buffer):
  Bunch
  of lines
  at start
  vshcmd: > ls
  many
  many
  files

Do (omode down motion works without a prompt above):
  jd\<C-p>

Expect:
  at start
  vshcmd: > ls
  many
  many
  files

Do (omode up motion works without a prompt below):
  \<C-n>jjd\<C-n>

Expect:
  Bunch
  of lines
  at start
  vshcmd: > ls
  many

Do (omode down motion from inside a prompt removes the current prompt only):
  \<C-n>0d\<C-n>

Expect:
  Bunch
  of lines
  at start
  many
  many
  files

# Checking counts work
Given vsh (vsh buffer):
  vshcmd: > ls
  bunch
  of
  files
  vshcmd: > echo Hello world
  Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world

Do (down motion moves over N prompts when given an argument N):
  3\<C-n>ix

Expect:
  vshcmd: > ls
  bunch
  of
  files
  vshcmd: > echo Hello world
  Hello world
  vshcmd: > xecho Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world

Do (down motion with arg N moves over N prompts when prompts are adjacent):
  4\<C-n>ix

Expect:
  vshcmd: > ls
  bunch
  of
  files
  vshcmd: > echo Hello world
  Hello world
  vshcmd: > echo Hello world
  vshcmd: > xecho Hello world
  vshcmd: > echo Hello world

" n.b. this behaviour is made special for when you're in the middle of an
" output and want to remove the rest of the output without removing the command
" below. It's not actually *for* the behaviour I test here.
Do (omode down motion with count of N stops before N'th prompt):
  d4\<C-n>

Expect:
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world

Do (up motion moves over N prompts when given argument N):
  3\<C-n>2\<C-p>ix

Expect:
  vshcmd: > xls
  bunch
  of
  files
  vshcmd: > echo Hello world
  Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world

Do (up motion with arg N moves over N prompts when prompts are adjacent):
  4\<C-n>3\<C-p>ix

Expect:
  vshcmd: > xls
  bunch
  of
  files
  vshcmd: > echo Hello world
  Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world
  vshcmd: > echo Hello world

" n.b. this behaviour is made special for when you're in the middle of an
" output and want to remove the rest of the output without removing the command
" below. It's not actually *for* the behaviour I test here.
Do (omode up motion with count of N stops before N'th prompt):
  4\<C-n>d3\<C-p>

Expect:
  vshcmd: > ls
  vshcmd: > echo Hello world


#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#
#                              Parsing Commands                               #
#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#
# Our options
Given vsh (vsh buffer):
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there


Do (prompt without matching whitespace is an invalid prompt):
  :1put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  -1
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (line solely containing b:vsh_prompt is a valid but empty command):
  :2put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 

  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (prompt with non-whitespace, non-hash text after is parsed as that text):
  :3put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (prompt with command preceded by spaces is parsed as a command including that whitespace):
  :4put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
    ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (prompt with command preceded by tabs is parsed as a command including that whitespace):
  :5put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (non-matching prompt because of whitespace mismatch is an invalid command):
  :6put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  -1
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (line matching the comment regexp is an invalid command):
  :7put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  -1
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (any prompt where the first trailing character is a hash is an invalid command):
  :8put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  -1
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (prompts followed by spaces and then a hash character are invalid commands):
  :9put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  -1
  vshcmd: >  	#ls
  hello there

Do (prompts followed by tabs before a hash character are invalid commands):
  :10put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  -1
  hello there

Do (lines without prompts are invalid commands):
  :11put =vsh#vsh#ParseVSHCommand(getline('.'))\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there
  -1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                Output Range                                 "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Given vsh (vsh buffer):
  vshcmd: >
  vshcmd: >

  vshcmd: >




  vshcmd: >


Do (OutputRange() returns the empty string when the cursor is on a prompt followed by another prompt):
  :s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: >

  vshcmd: >




  vshcmd: >

Do (OutputRange() returns a range that will select a single line output):
  :2s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: >3,3

  vshcmd: >




  vshcmd: >

Do (OutputRange() returns a range that will select a single line output when invoked inside that output):
  :3s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: >
  3,3
  vshcmd: >




  vshcmd: >

Do (OutputRange() returns a range that will select multi-line output):
  :4s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: >

  vshcmd: >5,8




  vshcmd: >

Do (OutputRange() returns a range that will select multi-line when invoked inside that output):
  :5,8s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: >

  vshcmd: >
  5,8
  5,8
  5,8
  5,8
  vshcmd: >

Do (OutputRange() on a prompt at the end of the buffer returns the empty string):
  :$s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: >

  vshcmd: >




  vshcmd: >


Given vsh (vsh buffer):
  hello there
  vshcmd: >
  hello there

Do (OutputRange() in an output without a command above works as if there were a command before the start of the buffer):
  :s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  hello there1,1
  vshcmd: >
  hello there

Do (OutputRange() on a command whose output reaches the end of the buffer works as if there were a command at the end of the buffer):
  :2s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  hello there
  vshcmd: >3,3
  hello there

Do (OutputRange() in output that reaches the end of the buffer works as if there were a command at the end of the buffer):
  :$s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  hello there
  vshcmd: >
  hello there3,3


Given vsh (vsh buffer):
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls
  hello there

Do (OutputRange() treats all lines starting with b:vsh_prompt stripped of whitespace the same):
  :%s/$/\=vsh#vsh#OutputRange()\<CR>

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: > ls
  vshcmd: >   ls
  vshcmd: > 	ls
  vshcmd: >	ls
  vshcmd: > # ls
  vshcmd: > #ls
  vshcmd: >   #ls
  vshcmd: >  	#ls11,11
  hello there11,11

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                            Save Output function                             "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  just some text
  above everything
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Save output does nothing when invoked on text without a prompt above it):
  \six

Expect:
  xjust some text
  above everything
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Invoking save output on command line comments out that line):
  2j\six

Expect:
  just some text
  above everything
  xvshcmd: > # vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (save output from inside the output of some command comments out that command line):
  3j\s

Expect:
  just some text
  above everything
  vshcmd: > # vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (save output from inside the output of some command does not move the cursor):
  3j\six

Expect:
  just some text
  above everything
  vshcmd: > # vshcmd: > ls
  xbin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (save output acting on a previously saved command does nothing):
  3j\s\six

Expect:
  just some text
  above everything
  vshcmd: > # vshcmd: > ls
  xbin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                           Unsave output function                            "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  just some text
  above everything
  vshcmd: > # vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Unsave does nothing when invoked on text without a prompt above it):
  \aix

Expect:
  xjust some text
  above everything
  vshcmd: > # vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Invoking unsave output when on a previously saved command line uncomments that line):
  2j\aix

Expect:
  just some text
  above everything
  xvshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Invoking unsave output when in the output of a saved command uncomments that command):
  3j\a

Expect:
  just some text
  above everything
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Invoking unsave output when in the output of a saved command does not move the cursor):
  3j\aix

Expect:
  just some text
  above everything
  vshcmd: > ls
  xbin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Invoking unsave output from a command line that was not previously saved does nothing):
  G\aix

Expect:
  just some text
  above everything
  vshcmd: > # vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  xvshcmd: > echo Hello

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                 New Prompt                                  "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


Given vsh (vsh buffer):
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello

Do (Getting a new prompt when on a command line inserts the new prompt after this commands output):
  \n

Expect:
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > 
  vshcmd: > echo Hello

Do (Getting a new prompt leaves the user in insert mode):
  \nx

Expect:
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > x
  vshcmd: > echo Hello

Do (Getting a new prompt from inside output behaves the same as when on the command above that output):
  j\nx

Expect:
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > x
  vshcmd: > echo Hello

Do (Getting a new prompt inserts a prompt after the current command when there is no output from that command):
  \<C-n>\<C-n>\nx

Expect:
  vshcmd: > ls
  bin            records    share     tentel_password.txt  TODO
  pstree_output  sensitive  temp_dir  test.vsh             xresources
  $ 
  vshcmd: > echo Hello
  vshcmd: > x

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                               Select Command                                "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > echo Hello there
  Hello there
  vshcmd: >    echo Hello there

Do (select a command does nothing before empty prompt):
  cicx

Expect:
  xvshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > echo Hello there
  Hello there
  vshcmd: >    echo Hello there

" Would prefer the select command to select "nothing", but don't know what that
" means so can't implement it.
" I expect it would mean special cases for each operator, so I'm not looking
" into it.
Do (select a command behaves reasonably when on an empty prompt):
  jcicx

Expect:
  vshcmd: >
  vshcmd: >x
  vshcmd: >    #echo Hello there
  vshcmd: > echo Hello there
  Hello there
  vshcmd: >    echo Hello there

Do (select a command ignores comment prompts):
  jjcicx

Expect:
  vshcmd: >
  vshcmd: >x
  vshcmd: >    #echo Hello there
  vshcmd: > echo Hello there
  Hello there
  vshcmd: >    echo Hello there


# Real command
Do (select inner command selects a command without preceding whitespace):
  jjjcicx

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > x
  Hello there
  vshcmd: >    echo Hello there


Do (Select outer command includes preceding whitespace):
  jjjcacx

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > x
  Hello there
  vshcmd: >    echo Hello there


# Select command when in output
Do (select inner command does the same when inside output as when at the command that created that output):
  jjjjcicx

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > x
  Hello there
  vshcmd: >    echo Hello there


Do (select a command does the same when inside output as when at the command that created that output):
  jjjjcacx

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > x
  Hello there
  vshcmd: >    echo Hello there


# Command with spaces
Do (select inner command leaves leading whitspace in a command):
  jjjjjcicx

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > echo Hello there
  Hello there
  vshcmd: >    x

Do (select outer command includes leading whitspace in a command):
  jjjjjcacx

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > echo Hello there
  Hello there
  vshcmd: > x

Do (command selection is redone with the '.' command as if typed again):
  jjjdacjj.

Expect:
  vshcmd: >
  vshcmd: > 
  vshcmd: >    #echo Hello there
  vshcmd: > 
  Hello there
  vshcmd: > 


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                             Output Text object                              "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  vshcmd: >
  vshcmd: >
  One line output
  vshcmd: >
  Multiple
  line
  output
  vshcmd: >
  Output at the
  end of the buffer

Do (Change output when no output):
  ciox

Expect:
  xvshcmd: >
  vshcmd: >
  One line output
  vshcmd: >
  Multiple
  line
  output
  vshcmd: >
  Output at the
  end of the buffer

Do (Change OUTPUT when no output):
  caox

Expect:
  x
  vshcmd: >
  One line output
  vshcmd: >
  Multiple
  line
  output
  vshcmd: >
  Output at the
  end of the buffer

Do (Change output when one line of output):
  jciox

Expect:
  vshcmd: >
  vshcmd: >
  x
  vshcmd: >
  Multiple
  line
  output
  vshcmd: >
  Output at the
  end of the buffer

Do (Change OUTPUT when one line of output):
  jcaox

Expect:
  vshcmd: >
  x
  vshcmd: >
  Multiple
  line
  output
  vshcmd: >
  Output at the
  end of the buffer

Do (Change output when multiple lines):
  jjjciox

Expect:
  vshcmd: >
  vshcmd: >
  One line output
  vshcmd: >
  x
  vshcmd: >
  Output at the
  end of the buffer

Do (Change output when multiple lines):
  jjjcaox

Expect:
  vshcmd: >
  vshcmd: >
  One line output
  x
  vshcmd: >
  Output at the
  end of the buffer


Do (Works with the redo '.' command):
  jjdioj.

Expect:
  vshcmd: >
  vshcmd: >
  vshcmd: >
  vshcmd: >
  Output at the
  end of the buffer

Given vsh (vsh buffer):
  Some text before first prompt
  vshcmd: > ls

Do (Selects output even if no prompt above):
  dio

Expect:
  vshcmd: > ls

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                      Select Command Block text object                       "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  vshcmd: > # echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi

Do (Selects when at start of buffer):
  vixx

Expect:
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  vshcmd: > # echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi

Do (Select above when in output):
  3jVixx

Expect:
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  vshcmd: > # echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi

Do (Select breaks at comment):
  4jvixx

Expect:
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > # echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi

Do (Select An execution block includes comments):
  4jvaxx

Expect:
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  a
  a
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi

Do (Select works at end of buffer):
  GVaxx

Expect:
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  a
  a
  vshcmd: > echo Hi
  vshcmd: > echo Hi
  vshcmd: > # echo Hi
  vshcmd: > echo Hi
  a
  a

Given vsh (vsh buffer):
  Some text before the first command
  vshcmd: > echo hello

Do (Select works at start of buffer):
  cixx

Expect:
  xSome text before the first command
  vshcmd: > echo hello

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                            Start Ranged Command                             "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  Text before first command
  vshcmd: > echo Hello there
  Hello there
  vshcmd: > echo Hello there
  These are some lines
  Hello there

Do (Output range works at start of file):
  \od\<CR>

Expect:
  vshcmd: > echo Hello there
  Hello there
  vshcmd: > echo Hello there
  These are some lines
  Hello there

Do (Output range inserted properly):
  j\od\<CR>

Expect:
  Text before first command
  vshcmd: > echo Hello there
  vshcmd: > echo Hello there
  These are some lines
  Hello there

Do (Output range calculated well at end of file):
  jjj\od\<CR>

Expect:
  Text before first command
  vshcmd: > echo Hello there
  Hello there
  vshcmd: > echo Hello there

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                              BOL override keys                              "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

# The function that "I" calls uses " " feedkeys(), and that interferes with
# Vader, hence don't test this.
Given vsh (vsh buffer):
  vshcmd: > echo hello
  vshcmd: >   echo hello
  vshcmd: > # Works on comments
  vshcmd: > 				echo characters with more than one space
  Also not a command

Do ('^' normal mode override):
  ^iv\<esc>j^iw\<esc>j^ix\<esc>j^iy\<esc>j^iz

Expect:
  vshcmd: > vecho hello
  vshcmd: >   wecho hello
  vshcmd: > # xWorks on comments
  vshcmd: > 				yecho characters with more than one space
  zAlso not a command

Do ('^' operator pending mode override);
  $c^v\<esc>j$c^w\<esc>j$c^x\<esc>j$c^y\<esc>j$c^z

Expect:
  vshcmd: > vo
  vshcmd: >   wo
  vshcmd: > # xs
  vshcmd: > 				ye
  zd

Do ('^' visual mode override):
  $v^cv\<esc>j$v^cw\<esc>j$v^cx\<esc>j$v^cy\<esc>j$v^cz

Expect:
  vshcmd: > v
  vshcmd: >   w
  vshcmd: > # x
  vshcmd: > 				y
  z

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                           Adds prompt on newline                            "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  vshcmd: > echo Hello
  other: > echo Hello

Do (Inserts new prompts accordingly):
  ox\<CR>y\<esc>joz

Expect:
  vshcmd: > echo Hello
  vshcmd: > x
  vshcmd: > y
  other: > echo Hello
  z

Execute (Change the prompt and new prompt is added accordingly):
  call vsh#vsh#SetPrompt('other: >')
  goto 1
  execute "normal! ox\<esc>joy\<CR>z"

Expect:
  vshcmd: > echo Hello
  x
  other: > echo Hello
  other: > y
  other: > z


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                       Convert some text into commands                       "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Given vsh (vsh buffer):
  echo Hello
  echo Hello
  echo Hello
  echo Hello
  echo Hello

Execute (VmakeCmds directly):
  2,3VmakeCmds

Expect:
  echo Hello
  vshcmd: > echo Hello
  vshcmd: > echo Hello
  echo Hello
  echo Hello

Do (VmakeCmds <F4> visual mode map):
  jvj\<F4>

Expect:
  echo Hello
  vshcmd: > echo Hello
  vshcmd: > echo Hello
  echo Hello
  echo Hello

Do (VmakeCmds <F4> normal mode map):
  j\<F4>j

Expect:
  echo Hello
  vshcmd: > echo Hello
  vshcmd: > echo Hello
  echo Hello
  echo Hello

Do (VmakeCmds <F4> normal mode map word motion):
  jw\<F4>/echo/e\<CR>

Expect:
  echo Hello
  vshcmd: > echo Hello
  vshcmd: > echo Hello
  echo Hello
  echo Hello

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                              vsh_clear_output                               "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Given vsh (vsh buffer):
  vshcmd: > false
  vshcmd: > echo Hello
  Hello
  vshcmd: > echo Hello; echo there
  Hello
  there
  vshcmd: > echo Hello; echo there
  Hello
  there

Execute (Remove non-existant output):
  python3 vsh_clear_output(1)

Expect:
  vshcmd: > false
  vshcmd: > echo Hello
  Hello
  vshcmd: > echo Hello; echo there
  Hello
  there
  vshcmd: > echo Hello; echo there
  Hello
  there

Execute (Remove single line output):
  python3 vsh_clear_output(2)

Expect:
  vshcmd: > false
  vshcmd: > echo Hello
  vshcmd: > echo Hello; echo there
  Hello
  there
  vshcmd: > echo Hello; echo there
  Hello
  there

Execute (Remove multi-line output):
  python3 vsh_clear_output(4)

Expect:
  vshcmd: > false
  vshcmd: > echo Hello
  Hello
  vshcmd: > echo Hello; echo there
  vshcmd: > echo Hello; echo there
  Hello
  there

Execute (Remove output at end of file):
  python3 vsh_clear_output(7)

Expect:
  vshcmd: > false
  vshcmd: > echo Hello
  Hello
  vshcmd: > echo Hello; echo there
  Hello
  there
  vshcmd: > echo Hello; echo there


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                               vsh_insert_text                               "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given vsh (vsh buffer):
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world

Execute (First line of output when not initialised is skipped):
  1 mark p
  1 mark d
  python3 vsh_insert_text(['Hello world'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world

Execute (First insert of an output):
  1 mark p
  1 mark d
  let b:vsh_initialised = 1
  python3 vsh_insert_text(['Hello world'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  Hello world
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world


Execute (Insert continuing an output):
  2 mark p
  4 mark d
  let b:vsh_initialised = 1
  python3 vsh_insert_text(['there there'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world
  there there
  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world

Execute (Insert at end of file):
  5 mark p
  $ mark d
  let b:vsh_initialised = 1
  python3 vsh_insert_text([' this is a test'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world this is a test

Execute (Multiline output):
  6 mark p
  $ mark d
  let b:vsh_initialised = 1
  python3 vsh_insert_text(['', 'Hello world', 'this is a test'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world
  Hello world
  this is a test


" Null bytes are encoded as newlines in the data given
Execute (Output with embedded NULL bytes):
  1 mark p
  1 mark d
  let b:vsh_initialised = 1
  python3 vsh_insert_text(['Hello\nworld', 'this is a test'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  Hello world
  this is a test
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world


Execute (Insert when insert mark has been lost):
  2 mark p
  let b:vsh_initialised = 1
  python3 vsh_insert_text(['there there'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  there there
  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world


Execute (Insert at end of buffer when no marks are around):
  let b:vsh_initialised = 1
  python3 vsh_insert_text(['', 'Hello world'], vim.current.buffer.number)

Expect:
  vshcmd: > echo 'Hello world' # test insert when no output already there
  vshcmd: > echo 'Hello world'; echo 'there there' # test basic insert
  Hello world

  vshcmd: > echo -n 'hello world'; echo ' this is a test' # joining lines
  hello world
  Hello world

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                          Function motion commands                           "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Given vsh (vsh buffer):
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

" Basic motion checks
Do (Motion over command blocks):
  ]]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > xecho -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards over command blocks):
  ]][[ix

Expect:
  vshcmd: > xecho -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion to end of command block):
  ][ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > xecho world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards to end of command block):
  ]][]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > xecho world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion to start at beginning of buffer):
  [[ix

Expect:
  vshcmd: > xecho -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion to end at end of buffer):
  Gdd2k][ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > xcommand

" Motion from middle of output and middle of commands
Do (Motion forwards):
  j]]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > xecho -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards over command blocks):
  ]]j[[ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > xecho -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion to end of command block):
  j][ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > xecho world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards to end of command block):
  ]]j[]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > xecho world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp


Do (Motion forwards when inside output):
  /temp\<CR>]]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > xcommand
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards when inside output):
  /temp\<CR>[]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > xecho world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

" Includes comments
Do (Motion over comments to end):
  ]]][ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > xecho world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion forwards over comments):
  ]]]]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > xecho -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards over comments):
  ]]]][[ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > xecho -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Motion backwards over comments to end of block):
  ]]]]][[]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > xecho world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

" Works with count
Do (Motion with count):
  3]]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > xcommand
  vshcmd: > command
  vshcmd: > command
  temp

Do (Backwards motion with count):
  3]]2[[ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > xecho -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Count to end):
  3][ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > xecho world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Count backwards to end):
  3]]2[]ix

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > xecho world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

" Works in operator mode
Do (Operator mode works linewise):
  d]]

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Operator mode to end of block works):
  d][

Expect:
  Hellothereworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Operator mode to start works with count):
  d2]]

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Operator mode works with count):
  d2][

Expect:
  Helloworld
  vshcmd: > echo -n Hello
  vshcmd: > # echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Do (Operator mode with count works backwards):
  3]]d2[[

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  vshcmd: > command
  vshcmd: > command
  temp

Do (Operator mode with count backwards has exception):
  3][d2[]

Expect:
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  temp

Given vsh (vsh buffer):
  output before
  first prompt
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  output
  after
  last prompt

Do (Motion forwards at start):
  ]]ix

Expect:
  output before
  first prompt
  vshcmd: > xecho -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  output
  after
  last prompt

Do (Motion forwards to end at start):
  ][ix

Expect:
  output before
  first prompt
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > xecho world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  output
  after
  last prompt


Do (Motion backwards at start):
  [[ix

Expect:
  xoutput before
  first prompt
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  output
  after
  last prompt

Do (Motion forwards at end):
  G]]ix

Expect:
  output before
  first prompt
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > command
  output
  after
  xlast prompt

Do (Motion backwards at end):
  G[[ix

Expect:
  output before
  first prompt
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > xcommand
  vshcmd: > command
  vshcmd: > command
  output
  after
  last prompt


Do (Motion backwards to end from end):
  G[]ix

Expect:
  output before
  first prompt
  vshcmd: > echo -n Hello
  vshcmd: > echo -n there
  vshcmd: > echo world
  Hellothereworld
  temp
  temp
  temp
  vshcmd: > command
  vshcmd: > command
  vshcmd: > xcommand
  output
  after
  last prompt


" I don't know why, but if this test isn't last then I get errors in Vader.
" TODO Figure out why -- is it the sleep command?
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                             Runs basic commands                             "
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Given vsh (vsh buffer):
  vshcmd: > echo Hello

Execute (Run this command):
  Vrerun
  " Sleep for a little while to give the pty time to respond
  " Remove the prompt printed by the pty if in nvim
  if has('nvim')
    sleep 1
    normal! Gdd
  endif

Expect:
  vshcmd: > echo Hello
  Hello

