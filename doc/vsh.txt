*vsh.txt*  Modifiable text pseudo terminal. *vsh* *Vsh*

Version; 1.0
Author:  Matthew Malcomson <hardenedapple@gmail.com>
License: MIT license {{{
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
}}}

Contents~
                        *vsh-contents*
Overview                |vsh-overview|
Running commands        |vsh-running|
Customisation           |vsh-customisation|
Mappings                |vsh-mappings|

==============================================================================
Overview~

                        *vsh-overview*
|Vsh| is a neovim plugin that behaves similarly to a terminal emulator, but
allows easy editing, searching, and modifying output by using a neovim buffer
on a simple text file as the middleman for input and output.

The benefits of |vsh| over the |:terminal| command are in retroactively
modifying or removing output, easily rerunning commands with slight
variations, and keeping a dynamic record of your shell session for easy
reproducibility.

It is important to stress that a |vsh| buffer is a simple text file. Any and
all standard vim commands are available in this buffer.

|Vsh| treats lines beginning with a prompt as commands, prompts with a
' #' after them are treated as comments. The default prompt is "vshcmd: > ".
For more information, see |vsh-prompt|.

Lines not beginning with a prompt are treated as output. Running a command
will replace the old output between the command and the next prompt with the
new output. See |vsh-running| for more info.

Commands may be run in any order, but there is an active, stateful bash
session that commands are sent to, so they may behave differently each time
they are run.

Text editing commands are provided for ease of working with output and
commands in the |vsh| buffer. There are text objects for a command and an
output, and a conveniance mapping to put the range of an output into the vim
command prompt ready to run an |:ex| command. See |vsh-editing| for more info.

There are two main difference between |vsh| and things like VimShell and
Conque:
https://github.com/Shougo/vimshell.vim
http://www.vim.org/scripts/script.php?script_id=2771 .
First, |vsh| is aimed around working with file-backed sessions that are saved
and reused, to be updated as required while working.
Second, |vsh| aims to allow re-running commands in place, so that
modifications to a command can easily be re-run without leaving a trace of the
initial command around.


==============================================================================
Running~
                        *vsh-running*

On opening a vsh buffer, |vsh| starts a process of your current 'shell' in a
new pseudo terminal. This shell is started in the same directory as the |vsh|
file was opened, and in the same manner as your normal shell apart from
setting the following environment variables. $PAGER is set to be empty,
$MANPAGER is set to "col -b" to remove special control characters, $EDITOR is
set to a |vsh| provided python script (see |vsh-editor|), and $TERM is set to
"dumb".

Running a command removes all lines between the cursor and the next prompt,
then sends the text after the prompt to the underlying shell process along
with a newline character. What the shell decides to do with this text is up to
it, but in their normal state most run this as a command and print the output.
|Vsh| inserts any output from the shell back into the |vsh| buffer after the
line whose command was last run. This is done asynchronously, so you can
continue to edit the vsh buffer while output is being inserted.
If you need to interrupt a command with a control character, you can use the
|vsh#vsh#SendControlChar()| function, (bound to <localleader>c by default).
This reads a character from the keyboard, and sends the C-[x] equivalent to
the underlying process, so that <localleader>cc will send ^C.
NOTE: If you run another command while the previous is still producing output
then the output of the first command will be placed after the prompt of the
second command. This is because there is no reliable way to tell when a
command has finished (especially when accounting for a subcommand taking
input).
NOTE: If you remove all previously inserted text, and the command line that
inserted that text, then remaining output will be inserted at the end of the
buffer.
NOTE: The position to put text into the buffer is remembered with a mark. This
has some consequences. See |vsh-marks|

                        *vsh-motion*
Mappings are provided on CTRL-N and CTRL-P by default to move to the next and
previous command line.

                        *vsh-prompt*
A |vsh| buffer has no special markings in it for the plugin to store
information (so that anyone without this plugin to view the file and
understand what's going on). The only way that |vsh| determines which lines
are commands and which lines are output is by checking the start of the line
for the |vsh| prompt. The default |vsh| prompt is "vshcmd: > " but can be
changed on a per buffer basis with |vsh#vsh#SetPrompt()|. See
|vsh-customisation| for details.

This method of distinguishing prompts has some consequences, most notably if
the output of a command includes a line starting with the prompt then that
line will be treated as a command. Hence you can store a "useful commands"
file, and "grep" it to search for tricks you once found. >

        vshcmd: > grep 'neat trick' ~/.vim/vsh_files/useful_commands
        vshcmd: > echo 'Hello world' # Such a a neat trick!!
<
These commands can then be run next.

If you know the output of a command will include a prompt, but you don't want
to treat it as a command, you can use the trick below. >

        vshcmd: > cat other_file.vsh | sed 's/^/ /'
         vshcmd: > echo 'Hellow orld' # Can never quite remember this
<
Vsh will not treat the line as a command.
NOTE: Unfortunately there is a bug where vim still treats these lines as
comments, and hence the prompt will still be automatically inserted when
adding a newline when the cursor is on these lines.


                        *vsh-completion*
Because many shells and REPL's provide completion abilities using the readline
library, |Vsh| provides special allowance to send readline control characters
to the underlying shell. When typing a command in insert mode, pressing CTRL-Q
removes previous output and sends characters intended to call the realine
function "possible-completions". This should list the possibile completions
under the current prompt so that one can use vim's normal completion keys to
choose one. Similarly, CTRL-S runs the bash readline function
"glob-list-expansions". These commands can also be run in normal mode with
<localleader>l and <localleader>g respectively.

                        *vsh-shell*
|Vsh| uses the 'shell' option to decide what shell to start. Most of the
features should work with any shell (it's just sending whatever you type to
that shell with a newline appended). When using a shell other than bash, the
features most likely to break are the completion keys. These use a bash
feature to find out what bindings readline is using, and hence any special
setup in your shell startup file will affect this.
NOTE: This program has only been tested extensively with the bash shell so
other shells are much more likely to have problems.
In particular, the C-shell detects that it is running in a dumb terminal
($TERM=dumb) and disables line editing, which the |vsh| completion keys rely
on.

                    *vsh-file-open* *vsh-'path'*
|Vsh| provides helper mappings that allow quick navigation to files printed
by the shell process. Pressing `gf` on a filename will run the normal `gf`
command with the local 'path' set to the working directory of the process
currently in the foreground of the terminal we are communicating with. This
means that it should work with programs like python that have changed
directory. >
    vshcmd: > python
    Python 3.6.0 (default, Jan 16 2017, 12:12:55)
    [GCC 6.3.1 20170109] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>>
    vshcmd: > import os; os.chdir(os.path.expanduser('~/.vim/bundle/vsh'))
    >>>
    vshcmd: > os.listdir('.')
    ['ftdetect', '.git', 'test.vsh', 'autoload', 'TODO.txt', 'README.md', 'tests', 'syntax', 'doc', 'demo', 'ftplugin']
    >>>
<
Pressing `gf` on `README.md` will open that file.

Similarly, |vsh| provides an insert-mode mapping for CTRL-X CTRL-F that runs
the completion in the directory that the current foreground process is in.
NOTE: These have only been tested on Linux ... I don't think it'll work on mac
or BSD (patches welcome :-) -- look in vsh_find_cwd()).

If the buffer-local variable `b:vsh_dir_store` is set, then just before
running a command, |vsh| will put the text " # <cwd>" directory after the
command line. When running |vsh-gf| or similar, |vsh| will first look for this
marker after a command line and if it's found will use that directory in
'path' instead of the current forground process'.
NOTE: This may cause problems in REPL's where the '#' character is not a
comment leader and is hence turned off by default.
To turn this on by default, put `let g:vsh_dir_store = 1` in your vimrc.

This is not used for CTRL-X CTRL-F, as it is assumed that you want to insert
filenames relative to the working directory of the process you're sending
that text to.

                *vsh-save* *vsh-activate* *vsh-deactivate*
When working in a |vsh| buffer pressing <CR> anywhere in the output of a
command will rerun that command. This can be annoying if you have written
notes across that output while you work. You should be able to undo the rerun
with `u` but in order to skip the bother you can deactivate the current
command with <localleader>s. This simply inserts a command at the start of the
command which means |vsh| won't run it on <CR>. The output can be reactivated
with <localleader>a.

            *vsh-text-objects* *vsh-command-object* *vsh-output-object*
                            *vsh-output-range*
In order to easily select the output of a command, or the command itself |vsh|
provides text objects bound to `ic` `ac` `ao` and `io` by default. The first
two operate on an inner-command and outer-command respectively, which is the
text after the prompt on the line that would be executed were <CR> pressed
where the cursor is now. The difference between `ac` and `ic` is that `ac`
includes any whitespace between the prompt and text on that line.
The second two operate on an inner-output and outer-output, which is the text
between two prompts. `ao` includes the command prompt that likely created that
output.
A special mapping on <localleader>o is provided to start a command with the
range that refers to the current output of a command pre-inserted in the
command line. This is slightly quicker to run filter commands with |:g|.

                    *vsh-run-multiple*
Sometimes it's convenient to send many lines at once to the underlying shell.
This can be achieved by using the command |vsh-:Vrerun| with a range.
This command sends all command lines in the given range to the underlying
process, and inserts output after the last command in that range. There is a
visual mode convenience mapping on <F3> to run this over the current visual
selection.

                     *vsh-send* *vsh-send-other* *vsh-send-buffer*
You can send text to the underlying terminal from another buffer with
|vsh-:VshSend|. This command takes a range and requires a buffer name as an
argument, it sends the text in that range to the process in the specified
buffer. An operator is provided under the default mapping of `<leader>vs` that
sends the text acted upon to the buffer whose number was provided as the
count. i.e. `3<leader>vsip` sends the text of the current paragraph to the
process in buffer number 3.
`<leader>vs` without a count uses the variable `b:vsh_alt_buffer`, which can
be set manually, but is also set by giving the mapping a count.
`<leader>vd` does the same as `<leader>vs` but dedents lines.


==============================================================================

Customisation~
                        *vsh-customisation*

        *g:vsh_insert_mark* *g:vsh_prompt_mark* *vsh-marks*

An implementation detail of |vsh| is that it uses user-modifiable marks to
remember where to put text read from the underlying process. If these marks
are lost, then |vsh| can't tell where to put text and simply puts it at the
end of the buffer. These marks are 'p and 'd by default, but can be changed
by setting the |g:vsh_insert_mark| and |g;vsh_prompt_mark| variables in your
vimrc.


          *g:vsh_default_prompt* *vsh#vsh#SetPrompt()* *b:vsh_prompt*
The current prompt is stored in the |b:vsh_prompt| variable. This variable is
locked with |:lockvar|, it must remain in sync with the |syntax| highlighting
and local 'commentstring', and 'comments' settings for the proper working of
this plugin. It may be changed on a per buffer basis with
|vsh#vsh#SetPrompt()|, to change the default you can set
|g:vsh_default_prompt| in your vimrc.

==============================================================================
Tips and Tricks~

If you often want to run many lines at once (but don't want to save this as a
shell script) you can put markers around them and use |vsh-:Vrerun| to send
them all at once. >
    vshcmd: > cd ../ # Here, run .,/ENDBLOCK/Vrerun
    vshcmd: > ls
    vshcmd: > cd -   # ENDBLOCK
<
This can be even more useful with the following function and binding >
    let g:command_prefix = 'vimcmd: '
    function s:ParseCommand(line)
      let come_here_prefix = substitute(g:command_prefix, ':', ';', '')
      let come_and_stay_prefix = substitute(g:command_prefix, ':', '!', '')

      let l:command_start = match(a:line, g:command_prefix)
      if l:command_start != -1
        return [0, a:line[l:command_start + len(g:command_prefix):]]
      end

      let l:command_start = match(a:line, come_here_prefix)
      if l:command_start != -1
        return [1, a:line[l:command_start + len(g:command_prefix):]]
      end

      let l:command_start = match(a:line, come_and_stay_prefix)
      if l:command_start != -1
        return [2, a:line[l:command_start + len(g:command_prefix):]]
      end

      return [0, '']
    endfunction

    function RunCommand(val)
      let orig_vcount = 0
      if v:count == 0 || a:val
        let line = getline('.')
      else
        let orig_vcount = v:count
        let line = getline(orig_vcount)
      endif

      let commandLine = s:ParseCommand(l:line)
      if l:commandLine[1] == ''
        echom 'Cannot parse line ' . l:line . ' for command, require prefix -- "' . g:command_prefix . '"'
      end

      if l:commandLine[0] > 0 && orig_vcount
        exe orig_vcount
      end

      execute l:commandLine[1]

      if l:commandLine[0] > 1 && !a:val
        exe "''"
      end
    endfunction

    nnoremap <silent> <F2> :<C-u>call RunCommand(0)<CR>
<
So that in a buffer with >
    vshcmd: > cd ../ # vimcmd! .,/ENDBLOCK/Vrerun
    vshcmd: > ls
    vshcmd: > cd -   # ENDBLOCK
< you can just press <F2> on the first line to run the block of commands.

==============================================================================
Mappings~
                            *vsh-mappings*

                *vsh-<buffer>-mappings*

                              *vsh-<Enter>* *vsh-<Return>* *vsh-<CR>*
<CR>                    Delete previous output and run current command. The
                        current command is determined by where the cursor is.
                        It is the next command above the cursor position. Hence
                        the action of <CR> if the cursor is anywhere marked [x]
                        below would be the same. >

            [x]vshcmd: > pw[x]d
            /home/hardenedapple
            ~ [14:0[x]1:56] $

<

                                *vsh-next-command* *vsh-CTRL-N*
CTRL-N           Move to the next command line.

                                *vsh-prev-command* *vsh-CTRL-P*
CTRL-P           Move to the previous command line.

                                *vsh-i_M-CR* *vsh-exec-and-newprompt*
<M-CR>        Run the current command, create a new prompt under the current
                command, and leave the cursor in insert mode at the end of
                that new prompt.

                                *vsh-<localleader>n* *vsh-newprompt*
<localleader>n  Create a new prompt under the output of the current command
                and leave the cursor in insert mode at the end of that new
                prompt.


                        *vsh-v_<F3>* *vsh-rerun-mapping* *vsh-:Vrerun*
:[range]Vrerun  Remove all output in the range, send all command
                lines to the underlying shell, and insert output after the
                last command.
<F3>            Visual mode mapping to do the above on the visual selection.


                        *vsh-v_<F4>* *vsh-make-cmds-mapping* *vsh-:VmakeCmds*
:[range]VmakeCmds  Put |b:vsh_prompt| at the start of every line in [range].
                   This is useful to change output or copied text into a
                   series of commands at the same time.
                   (e.g. if copying a few lines from a shell script).
<F4>            Visual mode mapping to do the above on the visual selection.

                            *vsh-<localleader>c* *vsh-control-char*
                          *vsh-send-control-char* *vsh-send-control*
<localleader>c  Read a single character from the user, and send the control
                modified version of that character to the underlying pseudo
                terminal. i.e. to send a ^C, type <localleader>cc

                        *vsh-possible-completions* *vsh-complete*
                        *vsh-completions* *vsh-<localleader>l*
                        *vsh-i_CTRL-Q*
<localleader>l  Request the current foreground process list possible
CTRL-Q          completions of the next word into the current buffer.
                NOTE May be fragile to different 'shell' settings than bash.
                     Should work in python, gdb, and other prompts too.

                        *vsh-glob-expansions* *vsh-glob*
                        *vsh-<localleader>g* *vsh-i_CTRL-S*
<localleader>g  Request the current foreground process list the glob
CTRL-S          expansions of the current word.
                NOTE Is known to be fragile to different 'shell' settings.
                As a workaround for troublesome shells, might want to have >
                    let b:vsh_completions_cmd[1] = " echo \n"
<               in your `ftplugin/vsh.vim` file.

                        *vsh-gx* *vsh-gf* *vsh-gF* *vsh-CTRL-W_gf*
                        *vsh-CTRL-W_gF* *vsh-CTRL-W_f* *vsh-CTRL-W_F*
gf, gF                Same as default vim bindings for these keys, but run
CTRL-W f CTRL-W F     accounting for the directory the current foreground
CTRL-W gf CTRL-W gF   process is in. See |vsh-file-open| for more information.

							*vsh-i_CTRL-X_CTRL-F*
CTRL-X CTRL-F       Run file completion |compl-filename| in the working
                    directory of the current foreground process.

                    *vsh-<localleader>a* *vsh-<localleader>s*
<localleader>s  Save current output by commenting out related command line.
<localleader>a  Activate current output by uncommenting related command line.

                    *vsh-^* *vsh-I*
I               Insert at the start of the current command line.
^               Move to the start of the current command line.
                (i.e. just after the prompt)

                *vsh-ic* *vsh-ac* *vsh-io* *vsh-ao*
ic          Act on the text of a command excluding extra whitespace between
            the prompt and this text.
ac          Act on the text of a command including extra whitespace between
            the prompt and this text.
io          Act on the output of a command excluding the command line itself.
ao          Act on the output of a command including the command line itself.


                        *vsh-global-mappings*

:[range]VshSend[!] {bufname}   *vsh-:VshSend*
        Send the lines in [range] to the process associated with buffer
        {bufname}.
        With a bang, removes the indentation of the first line in the range
        from all lines in the range.
<leader>vs             *vsh-<leader>vs*
        Send the lines in the motion acted upon to the process associated with
        buffer number [count].
<leader>vd              *vsh-<leader>vd*
        Same as <leader>vs, but removes the indentation of the first line off
        all lines in the range.
        This is useful for sending parts of a python function to a |vsh|
        buffer running a python interpreter.

 vim:tw=78:et:ft=help:norl:
